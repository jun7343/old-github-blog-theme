---
layout: post
title: "다이나믹 프로그래밍(Dynamic Programming)"
comments: true
author:
  name: Jun Yu
  github: jun7343
image: /assets/images/algorithm/dynamic-programming/stair.png
categories: 
  - algorithm
tags: 
  - 알고리즘
  - 다이나믹 프로그래밍
alt_title: "다이나믹 프로그래밍(Dynamic Programming)"

excerpt: "수학과 컴퓨터 과학, 그리고 경제학에서 동적 계획법(動的計劃法, dynamic programming)이란 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법을 말한다. 이것은 부분 문제 반복과 최적 부분 구조를 가지고 있는 알고리즘을 일반적인 방법에 비해 더욱 적은 시간 내에 풀 때 사용한다."
last_modified_at: 2020-10-28T12:34
---

### 다이나믹 프로그래밍 정의

> 수학과 컴퓨터 과학, 그리고 경제학에서 동적 계획법(動的計劃法, dynamic programming)이란 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법을 말한다. 이것은 부분 문제 반복과 최적 부분 구조를 가지고 있는 알고리즘을 일반적인 방법에 비해 더욱 적은 시간 내에 풀 때 사용한다.   
출처: [동적계획법-위키백과](https://ko.wikipedia.org/wiki/%EB%8F%99%EC%A0%81_%EA%B3%84%ED%9A%8D%EB%B2%95)   
<br>

다이나믹 프로그래밍은 우리말로 풀이하면 동적 계획법이다. 동적 계획법은 주어진 문제를 파악하여 점화식 세운다. 이후 주어진 점화식에 따라 결과를 배열에 저장한다. 점화식에 따라 결과를 저장하는 곳을 **메모이제이션**이라 한다. 결과를 저장함으로서 다음 요구하는 값을 처리하는 시간을 단축 시킬 수 있다.   
주로 메모이제이션을 사용하는 문제로는 계단 문제와 피보나치 문제가 있다. 계단 문제의 경우 계단은 연속 세번이상 밟지 못하며 각 계단에는 수가 주어진다. 마지막 계단을 무조건 밟아야 할때 최대로 얻을 수 있을 수는 몇인가? 라는 문제이다. 계단의 수가 적다면 직접 대입하면서 확인 할 수 있을 수는 있다. 하지만 여섯계단만 되어도 이는 쉽지가 않다는걸 알 수 있다.   <br><br>
<img src="/assets/images/algorithm/dynamic-programming/stair.png" class="align-center" alt="계단 문제">   <br>

처음에 이 문제를 접했을때 머리가 너무 복잡했다. 최댓값 변수 하나로 풀 수 있지 않을까? 라는 생각으로 무작정 풀어보려 했으나 하다보면 무슨 벽에 막혀 진척이 없었다. 사실 알고리즘 테스트 볼때는 무작정 코딩부터 시작하면 안된다. 문제를 읽고 어떻게 풀어나가기를 요구하는지를 아는것이 우선인데 나는 하지 않았다... 다시 문제를 보면 결론은 마지막 계단을 밟았을때의 최대의 수다. 즉 연속으로 밟았을때의 최대값이 크냐 아니면 건너뛰고 밟은 최대값이 크냐의 문제라는 것이다. 점화식을 세우자면 일단 각 계단의 최대값을 저장하는 메모이제이션 배열을 **dp**라 하고 각 계단의 수를 저장한 배열을 **stair** 배열이라 하겠다.   
**dp[n] = Math.max(stair[n] + dp[n-1], stair[n] + dp[n-2]);**   
Math.max의 경우 Math.max(a,b) a,b 중 최대값을 구해서 반환하는 함수이다. n 번째의 최대값을 구하려면 n-1 번째의 최대값을 더할지 n-2 번째의 최대값을 더할지 둘중 어느 값이 더 클지 비교하여 최대값을 저장하는 것이다. 해당 점화식은 n-2 하기때문에 dp 배열을 초기화 할때 3번째 배열까지는 최대값을 미리 저장시켜놓자 이 부분은 하드코딩으로 처리하자. 점화식만 보면 계단 문제의 경우 쉽다고 생각 될것이다. 그렇다 대부분 동적 계획법은 문제를 빠르게 이해하고 반복되는 연산을 찾아 점화식만 세우면 된다.    

계단 문제는 [계단 오르기-백준](https://www.acmicpc.net/problem/2579)에서 풀 수 있다.   <br>
복잡할거라 생각되는 문제를 보고 당황하지 말자, 문제를 읽다보면 반복되는 연산이 보일것이고 점화식만 잘 세우면 풀 수 있을것이다.   <br>


### 참조
- 위키백과
- 백준