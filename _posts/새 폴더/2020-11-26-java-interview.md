---
layout: post
title: "JAVA 기본 기술 면접 예상 질문"
comments: true
author:
  name: Jun Yu
  github: jun7343
image: /assets/images/code-language/java-interview/java-icon.jpg
categories: 
  - java
tags: 
  - java
  - interview
alt_title: "JAVA 기본 기술 면접 예상 질문"

excerpt: "기술면접에 대비하여 JAVA에 관련한 기본 기술 질문을 나열해보려 한다. 잘못된 부분이 있으면 수정토록 하겠습니다."
last_modified_at: 2020-12-01T20:15
---

기술면접에 대비하여 JAVA에 관련한 기본 기술 질문을 나열해보려 한다. 잘못된 부분이 있으면 수정토록 하겠습니다.

### JAVA 예상 질문

- **Collection 이란**
  - 데이터를 저장하는 기본적인 자료구조들을 한 곳에 모아 편하게 사용하기 위해서 제공하는 것을 의미한다. 즉 여러 원소를 담을 수 있는 자료구조이다. 종류로는 List, Queue, Set, Map이 있으며, Map의 경우 Collection을 상속 받지 않지만 Collection 자료구조로 속한다.
- **Generic 이란**
  - 제네릭을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있습니다. 컴파일러는 코드에서 잘못 사용된 타입 때문에 발생하는 문제점을 제거하기 위해 제네릭 코드에 대한 타입 체크를 한다.
- **GC(Garbage Collection) 이란**
  - Java 	프로세스 동작하는 과정에서 GC는 불필요한 또는 더 이상 사용하지 않는 객체들을 메모리에서 제거함으로써, Java 프로세스가 한정된 메모리에서 효율적으로 사용할 수 있게 해줍니다. Heap 메모리에서 효율적으로 관리 한다.
- **컴파일시 나오는 코드**
  - 빌드 시, 자바 파일(*.java)을 자바 컴파일러(javac.exe)를 이용해 JVM이 이해할 수 있는 바이트 코드(*.class) 파일로 변환하 고, 런타임 시 JVM이 바이트 코드(*.class)를 기계어로 변환한다.
  - 자바 인터프리터는 코드를 한 줄 씩 기계어로 변환하며, JIT 컴파일러는 자주 사용하는 코드를 미리 기계어로 변환 후 사용하므로 빠르다. JVM은 OS에 독립적이다. JVM은 OS와 프로그램 사이에서 기계어로 해석해주는 역할을 해주기 때문에 OS에 상관 없이 어디서나 실행이 가능하다.
- **스트림(Stream)이란**
  - 스트림이란 데이터의 흐름을 얘기하며 자바에서는 입출력을 위해 스트림을 사용한다.
  - FIFO 구조 이며, 단방향 이다. 이전 스트림을 처리해야하는 스레드 작업이 끝나지 않으면 다음 스트림에 대한 처리가 지연될 수 있다.
- **BufferedReader와 Scanner 차이**
  - 버퍼리더는 멀티 쓰레드에서 안전하며 스캐너는 안전하지 않습니다. 그리고 버퍼리더의 경우 한 줄을 통째로 입력 받는 형식으로 스캐너 보다 비교적 빠릅니다. 스캐너의 경우 데이터를 파싱 해서 원하는 타입으로 들어오기 때문에 시간이 걸린다.
- **ArrayList와 LinkedList 차이**
  - ArrayList의 경우 내부적으로 데이터를 배열에서 관리하며 데이터의 추가, 삭제를 위해 아래와 같이 임시 배열을 생성해 데이터를 복사하는 방법을 사용하고 있다. 대량의 데이터를 추가/삭제 하는 경우 그만큼 데이터의 복사가 많이 일어나게 되어 성능 저하가 발생하게 된다. 다만 각 데이터는 인덱스를 가지고 있어 한번에 참조가 가능하여 데이터 검색에는 유리하다. LinkedList의 경우 데이터를 저장하는 각 노드가 다음 노드와 이전 노드의 상태만 알고 있다. 그래서 데이터 추가/삭제 시 불필요한 데이터 복사가 없어 추가/삭제에 유리한 반면 검색에는 처음부터 노드를 순회해야 하기에 검색에는 불리하다.
- **Array sort와 Collection sort 차이**
  - Array sort의 경우 내부적으로 dual-pivot quick sort를 사용하며 collection sort의 경우 merge sort와 insert sort를 합친 timsort를 사용합니다. 둘의 차이로는 quick sort는 배열에서 좋은 성능을 보이지만 안정되지 않아 안정이 필요한 object sort에서는 collection sort를 많이 쓰인다.
- **클래스와 객체 그리고 인스턴스 차이**
  - 클래스는 객체를 만들기 위한 설계도 혹은 틀이라 할 수 있으며 연관 되어 있는 변수와 메서드의 집합으로 이루어져 있다. 인스턴스의 경우 클래스 즉 설계도를 바탕으로 구현되어 실체화 하면 인스턴스라 한다. OOP 관점으로서는 메모리에 할당되면 인스턴스라 하며 인스턴스는 객체에 포함된다고 할 수 있다.
  - 클래스와 객체의 차이는 클래스는 ‘설계도’이며, 객체는 ‘설계도로 구현한 모든 대상’을 의미한다.
  - 객체와 인스턴스는 클래스의 타입으로 선언 되었을 때 객체라 불리며, 그 객체가 메모리에 할당되어지면 인스턴스라 불린다. 객체는 현실 세계에 가깝고 인스턴스는 소프트웨어에 가깝다. 하지만 엄격하게 객체와 인스턴스를 나누긴 어렵다.
- **JVM 이란**
  - Java Virtue Machine 이라 하며, 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행한다. JVM은 JAVA와 OS 사이에서 중개자 역할을 수행하며 OS에 구애 받지 않고 재사용을 가능하게 해준다. JVM은 메모리 관리, GC, Collection을 수행한다. JVM은 스택기반의 가상머신이다.
- **결합과 응집도 설명**
  - 모듈의 독립성을 판단하는 지표로서, 결합도는 모듈과 모듈간의 상호 의존 정도를 응집도는 모듈 내부의 기능적인 집중 정도라고 할 수 있다. 결합도는 낮을수록 응집도는 높을수록 이상적인 모듈화이다. 하지만 극단적으로 높다고 다 좋은 것은 아니다. 상황에 맞게 적절히 낮고 적절히 높을수록 좋다.
- **Overloading과 Overriding 차이**
  - Overloading은 같은 이름의 함수를 여러 개 정의하며 파라미터는 다르게 받아 다양한 호출을 받는 것이며 Overriding은 상위 클래스의 메서드를 하위 클래스에서 재정의하여 사용하는 것을 말합니다.
- **Enum 이란**
  - 열거형이라 불리며, 서로 연관된 상수들의 집합이라고 할 수 있다. Enum을 사용함으로써 코드가 단순해지고 가독성이 좋아진다. 인스턴스 생성과 상속을 방지하여 상수값의 타입 안전이 보장되며, Enum class를 사용해 새로운 상수들의 타입을 정의함으로 정의한 타입 이외의 타입을 가진 데이터값을 컴파일시 체크한다.
- **Interface와 abstract 차이**
  - 두가지는 선언만 있고 구현 내용은 없는 클래스이다. 자기 자신이 new를 해서 객체를 생성할 수 없으며 추상클래스를 extends 받거나, interface를 implements 한 자식만이 객체를 생성할 수 있다. 추상 클래스는 abstract 메서드가 하나라도 존재하는 클래스를 말하며 일부 메서드는 구현되어 있는 메서드도 있다. 그래서 추상클래스를 상속 받는 클래스는 abstract 메서드를 반드시 구현해야 한다. Interface는 구현체 없이 메서드의 대한 명세만 되어 있으며, 인터페이스를 상속 받는 클래스에서는 인터페이스 메서드를 전부 다 구현해야 한다. 자바는 단일상속을 지원하기에 추상클래스는 단일 상속이지만, 인터페이스를 사용하면 implements를 구현 하는 부분에서 extends를 사용하여 다중 상속이 가능하다.
- **자바 동기화란**
  - 멀티스레드 환경에서 data의 안전성과 신뢰성을 보장하기 위해 동기화(synchronized)를 사용해 사용하는 해당 스레드를 제외한 나머지 스레드 접근을 막는 것을 얘기한다.
- **자바 직렬화란**
  - 자바 시스템 내부에서 사용되는 Object 또는 data를 외부 자바 시스템에서도 사용할 수 있게 byte 형태로 전송하는 기술을 얘기한다. 또는 JVM의 메모리에 상주(힙 또는 스텍)되어 있는 객체를 바이트 형태로 변환하는 기술이다. 역직렬화는 반대로 바이트 형태의 Data를 원래대로 Object나 Data로 변환하는 기술을 얘기한다. 중요한 점은 직렬화와 역직렬화 진행하는 시스템이 서로 다를 수 있는 걸 고려해야 하며 이에 대응 하기위해 직렬화와 역직렬화하는 Object 는 동일한 serialVersionUID를 가지고 있어야 한다.
- **바이트 코드란?**
  - 바이트 코드는 가상 머신에서 이해할 수 있는 코드를 위한 이진표현법이다. 어떤 플랫폼이든 종속되지 않고 실행될 수 있는 가상머신용 코드이다.
- **접근 제한자 종류**
  - Public: 모든 접근을 허용
  - Protected: 같은 패키지(폴더)에 있는 객체와 상속관계의 객체들만 허용
  - Default: 같은 패키지(폴더)에 있는 객체들만 허용
  - Private: 현재 객체내에서만 허용
- **Java 언어 장단점**
  - 객체지향 언어이며, 운영체제 독립적이다. 그리고 다중 스레드를 지원하며 자동 메모리 관리(Garbage Collection)를 해준다. 그리고 배우기 쉽다. 단점으로는 속도부분에서는 느리다. 하드웨어에 맞게 컴파일된 상태가 아니라 실행시 해석되기에 느리다. 그렇지만 바이트 코드를 기계어로 변환해주는 JIT 컴파일러와 Hotspot(향상된 최적화 기술)과 같은 기술 적용으로 JVM 기능이 향상되어 속도부분은 많이 개선되었다. 그리고 불편한 예외처리가 있다.
- **OOP란?**
  - 객체지향 프로그래밍(Object Oriendted Programming)은 컴퓨터 프로그램을 객체들의 모임으로 파악하고자 하는 프로그래밍의 패러다임 중에 하나이다. 각 객체들은 서로 메시지를 주고 받을 수 있으며 데이터를 처리할 수 있다. 객체지향 프로그래밍을 함으로써 프로그램을 유연하고 변경을 용이하기 할 수 있으며 직관적인 코드 분석 가능과 프로그램 개발 및 보수를 간편하게 한다. 객체지향 프로그래밍은 강한 응집력과 약한 결합력을 지향한다. 기본 구성요소로는 클래스와 객체 그리고 메서드다.
- **OOP 4가지 기본 원칙**
  - 캡슐화: 캡슐화는 객체의 데이터를 외부에서 직접 접근을 하지 못하게 막고 함수를 통해서만 조작이 가능하게 하는 것이다.
  - 추상화: 객체들이 가지고 있는 공통의 특성들을 파악하고 불필요한 특성을 제거하고 공통적인 부분을 뽑아 이름을 붙인다.
  - 상속: 상위 개념의 특징을 하위 개념이 물려 받는 것을 얘기한다.
  - 다형성: 오버라이딩과 오버로딩이 이에 해당하며 같은 형태의 코드가 다른 행위를 하는 것을 의미한다.
- **OOP의 5대 원칙(SOLID)**
  - Single Responsibility Principle(단일 책임 원칙): 소프트웨어의 설계 부품(클래스, 함수 등)은 단 하나의 책임만을 가져야 한다. // 책임은 기능의 의미로 해석된다.
  -  Open-Closed Principle(개방-폐쇄 원칙): 기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계 해야 한다. 변경되는 것이 무엇인지 초점을 맞추고 변경된 것이 이전 내용에 영향을 미치지 않아야 한다.
  - Liskov Substitution Principle(리스코프 치환 원칙): 리스코프 치환 원칙은 MIT 컴퓨터 사이언스 교수인 리스코프가 제안한 설계 원칙이다. 부모 클래스와 자식 클래스 사이에 행위에는 일관성이 있어야 한다는 원칙이며, 객체 지향 프로그래밍에서 부모 클래스의 인터페이스 대신 자식 클래스 인터페이스를 사용해도 문제가 없어야 한다는 것을 의미한다.
  - Dependency Inversion Principle(의존 역전 원칙): 의존 관계를 맺을 때, 변화하기 쉬운 것 보단 변화하기 어려운 것에 의존해야 한다는 원칙이다. DIP 만족하는 것은 구체적인 클래스보단 인터페이스나 추상클래스와 관계를 맺는다는 것이다.
  - Interface Segregation Principle(인터페이스 분리 원칙): 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 하나의 일반적인 인터페이스보다는 여러 개여 구체적인 인터페이스가 낫다. 즉 자신이 사용하지 않는 기능(인터페이스)에는 영향을 받지 말아야 한다.
- **Non-static 멤버와 static 멤버의 차이**
  - 공간적 특성: non-static의 멤버는 객체마다 별도 존재(인스턴스 멤버), static의 멤버는 클래스당 하나 생성하며 멤버는 객체 내부가 아닌 별도의 공간(클래스 코드가 적재되는 메모리)에 생성. 클래스 멤버라고 부름
  - 시간적 특성: non-static은 객체 생성 시 멤버도 생성되며 객체 생성 후 사용할 수 있으며 객체가 소멸되면 멤버도 같이 사라진다. Static의 경우 클래스 로딩시에 생성 되며 객체가 생성되기전에 이미 생성 되어 있다. 객체가 생기기전에도 사용할 수 있고 객체가 소멸되어도 멤버는 사라지지 않고 프로그램이 종료되어야 사라진다.
  - 공유의 특성: non-static은 공유 되지 않고 멤버는 객체 내에 각각 공간 유지 한다. Static의 경우 동일한 클래스의 모든 객체들의 의해 공유된다.
- **Final 키워드란**
  - Final 변수: 상수라고 불리며, 변수를 선언과 동시에 초기화하며 이후에 값을 수정 할 수 없다. 오직 Get만 가능.
  - Final 메서드: 오버라이딩이 불가능하며, 상속 받은 그대로 사용해야 한다.
  - Final 클래스: 상속이 불가능하고, Subclass를 만들 수 없다.
- **쓰레드 풀 이란**
  - 무제한의 쓰레드 생성을 막고 쓰레드 관리를 하기 위해 미리 생성된 쓰레드들이다. 쓰레드 풀을 사용함으로써 프로그램 성능 저하를 방지하고, 다수의 사용자 요청을 처리할 수 있다. 하지만 너무 많은 쓰레드를 생성시 메모리 낭비와 노는 쓰레드가 발생된다.
- **Call by value와 Call by reference 설명**
  - Call by value는 값의 의한 호출이며 메서드 호출 시에 사용되는 인자의 메모리에 저장되어 있는 값(value)을 복사하여 보낸다.
  - Call by reference는 참조의 의한 호출이며 메서드 호출 시 사용되는 인자 값의 메모리에 저장되어 있는 주소를 복사하여 보낸다.
- **자바에서 쓰레드를 구현하기 위한 2가지 방법**
  - Thread를 extends 받아 사용하는 방법과 Runnable을 implements 받아 사용하는 2가지 방법이 있다. Thread를 상속 받아서 사용하면 다른 상속을 받을 수 없으며 한번 사용하면 재사용이 불가능하다. 다만 Runnable의 경우 구현 받아서 사용하므로 다른 클래스를 상속 받아서 사용할 수 있으며, Runnable를 통해 Thread를 구현하면 재사용이 가능하다.
- **Parameter와 Argument 차이**
  - Parameter는 함수 혹은 메서드 정의에서 나열되는 변수 명이며, Argument는 함수 혹은 메서드를 호출 할 때 전달 혹은 입력되는 실제 값이다.
- **리플랙션 이란?**
  -	컴파일러를 무시한 채 런타임 상황에서 메모리에 올라간 클래스나 메서드 등의 정의를 동적으로 찾아 조작할 수 있는 행위이다. 프레임워크에서 유연성이 있는 동작을 위해 자주 사용됩니다.
- **POJO란?**
  -	Plain Old JAVA Object의 준말, 오래된 방식의 자바 오브젝트 이다. 특정한 자바 모델이나 기능, 프레임워크 등을 따르지 않는 자바 오브젝트를 말한다.
- **직렬화란?**
  -	자바에서 입출력에 사용되는 것은 스트림이라는 데이터 통로를 통해 이동한다. 하지만 객체는 바이트형이 아니기 떄문에 스트림을 통해서 저장하거나 네트워크를 통해서 전송하는 것은 불가능하다. 따라서 객체를 스트림으로 입출력 하기 위해서 바이트 배열로 변환하는 것을 직렬화라고 한다.
- **자바 클래스 멤버 초기화 순서에 대해 설명**
  -	Static 변수 선언부는 클래스가 로드 될 때 변수가 제일 먼저 초기화 된다. 필드 변수선언부는 객체가 생성될 때 heap 메모리 영역에 올라가고 생성자 block 보다 앞서 초기화 된다. 생성자 block 역시 heap 메모리 영역에 올라가는데 이 때 필드 변수가 초기화 될 때 까지 JVM에서 로킹한다.
- **JDBC란?**
  -	자바에서 데이터베이스에 접속할 수 있도록 해주는 자바 API이다. JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트 하는 방법을 제공한다.
- **메모리 상수풀 영역에 대해서 설명**
  -	힙 영역에서 생성되고 자바 프로세스 종료까지 계속 유지되는 메모리 영역이다. 기본적으로 JVM에서 관리하며, 프로그래머가 작성한 상수에 대해 최우선적으로 찾아보고 없으면 상수풀에 추가 후 그 주소 값을 리턴 해 준다. 이로써 메모리 절약 효과를 가지고 올 수 있다.
- **자바 메모리 영역에 대해서 설명**
  -	메서드 영역: static 변수, 전역 변수, 코드에서 사용되는 클래스 정보들이 올라간다. 코드에서 사용되는 클래스들을 클래스 로더가 읽고 클래스 별로 분류해서 저장한다.
  -	스택: 지역 변수, 메서드 등이 할당되는 LIFO 방식의 메모리.
  -	힙: new 연산자를 통해 동적 할당된 객체들이 저장되고, 메모리는 GC(Garbage Colleiction)에 의해 관리.

